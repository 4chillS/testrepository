## **Как работает в связке NGINX + PHP + APACHE, когда делает запрос клиент**

Комбинация **NGINX + Apache + PHP** часто используется для повышения производительности и гибкости веб-сервера. Эта связка позволяет объединить преимущества NGINX (высокая производительность в качестве фронтенд-сервера) и Apache (гибкость и поддержка PHP через модули). Рассмотрим, как это работает и что происходит при клиентском запросе.


Комбинация **NGINX + Apache + PHP** часто используется для повышения производительности и гибкости веб-сервера. Эта связка позволяет объединить преимущества NGINX (высокая производительность в качестве фронтенд-сервера) и Apache (гибкость и поддержка PHP через модули). Рассмотрим, как это работает и что происходит при клиентском запросе.

### Основные компоненты

1. **NGINX** — фронтенд-сервер, принимающий все запросы от клиентов. Он работает как обратный прокси-сервер и может обрабатывать статические файлы (CSS, JavaScript, изображения).
2. **Apache** — бэкенд-сервер, который выполняет динамические запросы (PHP). Apache обрабатывает запросы к PHP-скриптам через модуль PHP (mod_php) или FastCGI (PHP-FPM).
3. **PHP** — интерпретатор PHP, который обрабатывает PHP-код и возвращает результат Apache.

### Поток обработки клиентского запроса

1. **Клиент отправляет HTTP-запрос к серверу**:
    
    - Запрос поступает на сервер NGINX, который слушает порт 80 (HTTP) или 443 (HTTPS).
2. **NGINX обрабатывает запрос**:
    
    - NGINX проверяет тип запроса:
        - **Статический контент** (например, изображения, CSS, JavaScript): NGINX обрабатывает запрос сам, не передавая его дальше.
        - **Динамический контент** (например, запрос к PHP-скрипту): NGINX перенаправляет запрос на Apache через прокси.
3. **Передача запроса от NGINX к Apache**:
    
    - NGINX выступает в роли обратного прокси и пересылает запрос на Apache через `proxy_pass` (HTTP) или `fastcgi_pass` (FastCGI).
    - Это делается по локальному соединению (например, через `localhost:8080`), где Apache слушает другой порт.
4. **Apache обрабатывает PHP-запрос**:
    
    - Apache получает запрос и передает его PHP-интерпретатору.
    - В зависимости от конфигурации, PHP может работать через:
        - **mod_php**: Apache загружает PHP как модуль и выполняет скрипт напрямую.
        - **PHP-FPM (FastCGI Process Manager)**: Apache передает запрос через FastCGI к PHP-FPM, который обрабатывает PHP-код.
5. **Выполнение PHP-кода и генерация ответа**:
    
    - PHP интерпретирует скрипт, обращается к базе данных (если необходимо) и формирует HTML-ответ.
6. **Возвращение ответа от Apache к NGINX**:
    
    - Apache отправляет сгенерированный HTML-ответ обратно на NGINX.
7. **NGINX возвращает ответ клиенту**:
    
    - NGINX получает ответ от Apache и отправляет его клиенту.


### Пример конфигурации NGINX

Простой пример конфигурации NGINX в связке с Apache:

```server {
    listen 80;
    server_name example.com;

    location / {
        proxy_pass http://127.0.0.1:8080;  # Прокси на Apache
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location ~* \.(css|js|jpg|jpeg|png|gif|ico|svg)$ {
        root /var/www/html;
        expires 30d;
        access_log off;
    }
}
````

### Пример конфигурации Apache

Простой пример конфигурации Apache:

```
<VirtualHost *:8080>
    ServerName example.com
    DocumentRoot /var/www/html

    <Directory /var/www/html>
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    # PHP-FPM через FastCGI
    <FilesMatch \.php$>
        SetHandler "proxy:unix:/var/run/php/php-fpm.sock|fcgi://localhost/"
    </FilesMatch>
</VirtualHost>
````

#### Преимущества использования связки NGINX + Apache + PHP

1. **Высокая производительность**:
    
    - NGINX быстрее обрабатывает статический контент и может кэшировать ответы.
    - Apache занимается только динамическим контентом, что снижает нагрузку.
2. **Гибкость и совместимость**:
    
    - Apache поддерживает `.htaccess`, что полезно для настроек на уровне директории.
    - NGINX может использоваться для балансировки нагрузки и защиты от DDoS-атак.
3. **Легкость масштабирования**:
    
    - NGINX можно использовать для проксирования запросов на несколько серверов Apache/PHP.

### Заключение

Связка **NGINX + Apache + PHP** объединяет лучшие стороны двух веб-серверов:

- **NGINX** обеспечивает высокую производительность и быстро обрабатывает статический контент.
- **Apache** обрабатывает сложные запросы и динамический контент с поддержкой PHP.
- **PHP** выполняет серверный код и генерирует динамические страницы.

Такой подход позволяет создавать надежные и производительные веб-приложения, особенно при высокой нагрузке и больших объемах трафика.

---

Связка **NGINX + PHP-FPM (FastCGI Process Manager)** — это популярное решение для серверов, обрабатывающих PHP-запросы. Она обеспечивает высокую производительность и гибкость при обработке веб-запросов. Давайте разберём, как происходит процесс обработки запроса в такой конфигурации.

### Что такое PHP-FPM и FastCGI

- **FastCGI** — это бинарный протокол, который используется для взаимодействия веб-сервера (например, NGINX) с приложениями (в данном случае с PHP). FastCGI значительно быстрее традиционного CGI, так как процессы не завершаются после обработки каждого запроса, а остаются в памяти, готовые принять следующий запрос.
- **PHP-FPM (FastCGI Process Manager)** — это менеджер процессов, который запускает и управляет пулом PHP-процессов, обрабатывающих запросы через FastCGI. PHP-FPM позволяет обрабатывать несколько запросов одновременно, эффективно распределяя нагрузку.

### Поток запроса: шаг за шагом

1. **Клиент отправляет HTTP-запрос**:
    
    - Клиент (например, веб-браузер) отправляет запрос, например, `GET /index.php HTTP/1.1`.
2. **NGINX принимает запрос**:
    
    - NGINX, работающий на переднем уровне, принимает запрос от клиента.
    - NGINX проверяет, относится ли запрос к **статическому контенту** (CSS, JS, изображения). Если это так, NGINX возвращает его напрямую из файловой системы.
3. **NGINX определяет, что запрос требует обработки PHP**:
    
    - Если запрос касается PHP-скрипта (например, `index.php`), NGINX перенаправляет его на PHP-FPM с помощью FastCGI.
4. **NGINX отправляет запрос на PHP-FPM**:
    
    - NGINX передаёт запрос через **FastCGI** с использованием **Unix-сокета** (`/var/run/php/php-fpm.sock`) или **TCP-соединения** (`127.0.0.1:9000`).
    - NGINX формирует специальные FastCGI-заголовки и передаёт их PHP-FPM, включая переменные окружения (например, `SCRIPT_FILENAME`, `QUERY_STRING`, `REQUEST_METHOD`).
5. **PHP-FPM обрабатывает запрос**:
    
    - PHP-FPM принимает запрос и выбирает свободный процесс из пула, чтобы обработать его.
    - Выбранный PHP-процесс интерпретирует PHP-код, выполняет его и генерирует HTML-ответ (или другой контент).
    - Во время выполнения PHP-скрипт может обращаться к базе данных, файловой системе и другим ресурсам.
6. **PHP-FPM возвращает ответ NGINX**:
    
    - PHP-FPM завершает выполнение скрипта и отправляет результат (HTML-контент) обратно в NGINX через FastCGI.
7. **NGINX отправляет ответ клиенту**:
    
    - NGINX получает ответ от PHP-FPM и передаёт его клиенту.

### Пример конфигурации NGINX для работы с PHP-FPM

```server {
    listen 80;
    server_name example.com;
    root /var/www/html;

    # Обработка статических файлов
    location / {
        try_files $uri $uri/ =404;
    }

    # Обработка PHP-файлов
    location ~ \.php$ {
        include fastcgi_params;
        fastcgi_pass unix:/var/run/php/php-fpm.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}
````

Пример конфигурации PHP-FPM (php-fpm.conf)
```
; Основной конфигурационный файл PHP-FPM
[global]
error_log = /var/log/php-fpm.log

; Настройки пула процессов (www.conf)
[www]
listen = /var/run/php/php-fpm.sock
listen.owner = www-data
listen.group = www-data
user = www-data
group = www-data

pm = dynamic
pm.max_children = 50
pm.start_servers = 5
pm.min_spare_servers = 5
pm.max_spare_servers = 10
````

### Разъяснение конфигурации

- **fastcgi_pass**: Указывает, куда NGINX отправляет запросы PHP (Unix-сокет или TCP).
- **include fastcgi_params**: Загружает стандартные FastCGI-заголовки (переменные окружения), такие как `SCRIPT_FILENAME` и `QUERY_STRING`.
- **fastcgi_param SCRIPT_FILENAME**: Определяет полный путь к исполняемому PHP-скрипту.

### Преимущества связки NGINX + PHP-FPM

1. **Высокая производительность**:
    
    - NGINX эффективно обрабатывает статические файлы, а PHP-FPM позволяет одновременно обрабатывать несколько PHP-запросов.
    - Использование Unix-сокетов снижает накладные расходы по сравнению с TCP.
2. **Гибкость и масштабируемость**:
    
    - Можно настроить несколько пулов процессов PHP-FPM с различными параметрами для разных веб-приложений.
    - NGINX может балансировать нагрузку между несколькими серверами PHP-FPM.
3. **Меньше памяти**:
    
    - В отличие от Apache с mod_php, NGINX не загружает PHP-интерпретатор в каждый процесс, что снижает использование памяти.

### Недостатки

1. **Сложность конфигурации**:
    - Требуется настройка двух компонентов: NGINX и PHP-FPM, что может быть сложнее, чем использование Apache с mod_php.
2. **Ошибки FastCGI**:
    - Ошибки конфигурации FastCGI могут привести к проблемам, таким как `502 Bad Gateway`, если PHP-FPM не отвечает.

### Ошибки и их решение

- **502 Bad Gateway**: NGINX не может соединиться с PHP-FPM. Проверьте, что PHP-FPM запущен и путь к сокету правильный.
- **504 Gateway Timeout**: PHP-скрипт выполняется слишком долго. Увеличьте `fastcgi_read_timeout` в конфигурации NGINX.

### Итог

Связка **NGINX + PHP-FPM** является быстрым и эффективным решением для обработки PHP-запросов. NGINX принимает запросы и обрабатывает статический контент, а PHP-FPM отвечает за выполнение PHP-кода. Это решение хорошо масштабируется и подходит для высоконагруженных веб-сайтов и приложений.


---


### Что такое kvm(не гипервизор)? Как можно его использовать?

- Ответ
    
    KVM (или kvm over ip) — устройство, позволяющее передавать видеосигнал и ввод с мыши/клавиатуры по сети с использованием IP-протокола от вашего сервера. При помощи KVM вы можете перезагрузить сервер, получить доступ в BIOS сервера и к другим функциям, которые невозможно выполнить на сервере через терминал. То есть он обособлен от операционной системы.
    
    Часто используется как последнее средств. Когда сервер не грузится, или есть ещё какой-то программный или системный сбой.
    
    KVM - это аббревиатура, состоящая из слов. Клавиатура, монитор(видео), мышь.

---
### Что такое IPMI? Какие подсистемы он в себя включает?


- Ответ
    
    IPMI (Intelligent Platform Management Interface) – это интерфейс для удаленного мониторинга и управления физическим состоянием сервера.
    
    Как я понимаю, модуль находится внутри самого сервера. И называется он BMC. Контроллер управления.
    
    В случае утраты контроля над работой сервера, можно удаленно управлять его работой, а именно:
    
    - получить доступ к консоли, изменить настройки BIOS;
        
    - перезагрузить, включить/выключить сервер;
        
    - ознакомиться с состоянием сервера (слежение за температурными датчиками, датчиками напряжения, состояние блока питания, скорость вращения вентиляторов);
        
    - подключение образов .iso.
        
    
    Но вообще, BMC ― это отдельный компьютер со своим программным обеспечением и сетевым интерфейсом, который распаивают на материнской плате или подключают как плату расширения по шине PCI management bus.
    
    К BMC контроллеры подключаются через интерфейс IPMB (Intelligent Platform Management Bus ― шина интеллектуального управления платформой). IPMB ― это шина на основе I2C (Inter-Integrated Circuit), по которой BMC перенаправляет команды управления к различным частям архитектуры:
    
    - Общается с дополнительными контроллерами (MCs)
    - Считывает данные сенсоров (Sensors)
    - Обращается к энергонезависимому хранилищу (Non-Volatile Storage)
    
    Архитектура IPMI реализована так, что удаленный администратор не имеет прямого доступа к компонентам системы. Например, чтобы получить данные с сенсоров, удаленный администратор посылает команду на BMC, а BMC в свою очередь обращается к сенсорам.
---


### Какие преимущества предоставляет IPMI в сравнении с kvm?

- Ответ
    
    Недостатки модуля IP-KVM в сравнении с IPMI
    
    Традиционные внешние IP-KVM устройства позволяют вам удаленно работать только с консолью своего сервера, отсутствует возможность управления питанием, монтирования образов и контроля состояния датчиков сервера.
    
    У IP-KVM есть несколько ключевых недостатков:
    
    - отсутствие постоянного доступа к управлению сервером (чтобы воспользоваться IP-KVM, вам нужно создать запрос в техподдержку с просьбой подключить к вашему серверу временный IP-KVM в датацентре; заявку желательно подавать заранее, подключение занимает от 15 до 30 минут в лучшем случае; в подключении KVM может быть отказано, если сейчас в наличии нет свободного оборудования);
    - отсутствие возможности управлять питанием, монтировать образы и контролировать состояние датчиков сервера.
---
### Модели процессора, количестве физических и логических ядер, поддерживаемых инструкциях, режиме работы?

- Модель процессора `cat /proc/cpuinfo`

```
model name	: Intel(R) Xeon(R) CPU E5-2620 0 @ 2.00GHz
model		: 45
```

Ядра физические и логические

```
vm13 : ~ [0] # grep "cpu cores" /proc/cpuinfo |sort -u |cut -d":" -f2
 4
vm13 : ~ [0] # grep -c "processor" /proc/cpuinfo
4
```


---

### Типы оперативной памяти, модели материнской платы, версии BIOS?

````
**Оперативная память** 

```
dmidecode --type memory 
# dmidecode --type 17
# dmidecode 2.11
SMBIOS 2.8 present.

Handle 0x1100, DMI type 17, 40 bytes
Memory Device
	Array Handle: 0x1000
	Error Information Handle: Not Provided
	Total Width: Unknown
	Data Width: Unknown
	Size: 9216 MB
	Form Factor: DIMM
	Set: None
	Locator: DIMM 0
	Bank Locator: Not Specified
	Type: RAM
	Type Detail: Other
	Speed: Unknown
	Manufacturer: QEMU
	Serial Number: Not Specified
	Asset Tag: Not Specified
	Part Number: Not Specified
	Rank: Unknown
	Configured Clock Speed: Unknown

Handle 0x004F, DMI type 17, 34 bytes
Memory Device
	Array Handle: 0x003F
	Error Information Handle: Not Provided
	Total Width: 72 bits
	Data Width: 64 bits
	Size: 16384 MB
	Form Factor: DIMM
	Set: None
	Locator: P2_DIMMH2
	Bank Locator: Node1_Bank0
	Type: DDR3
	Type Detail: Registered (Buffered)
	Speed: 1333 MHz
	Manufacturer: Samsung            
	Serial Number: 85D3A920     
	Asset Tag: Dimm10_AssetTag
	Part Number: M393B2G70BH0-Y
	Rank: 2
	Configured Clock Speed: 1333 MHz
```

Материнская плата

```

dmidecode --type baseboard
Handle 0x0002, DMI type 2, 15 bytes
Base Board Information
	Manufacturer: Supermicro
	Product Name: X9DR3-F
	Version: 0123456789
	Serial Number: VM16BS021748
	Asset Tag: To be filled by O.E.M.
	Features:
		Board is a hosting board
		Board is replaceable
	Location In Chassis: To be filled by O.E.M.
	Chassis Handle: 0x0003
	Type: Motherboard
	Contained Object Handles: 0
```

Версия bios

```bash
storage8 : ~ [130] # dmidecode --type BIOS
# dmidecode 2.11
SMBIOS 2.7 present.

Handle 0x0000, DMI type 0, 24 bytes
BIOS Information
	Vendor: American Megatrends Inc.
	Version: 3.2a
```
````



---


### Текущих значениях датчиков напряжения, температуры, оборотов вентиляторов?


Ответ, нужно дополнить

Температура и всякие такие штуки можно смотреть в `sensors`

```shell
sorsstorage13 : ~ [0] # sensors
coretemp-isa-0001
Adapter: ISA adapter
Core 0:       +32.0°C  (high = +85.0°C, crit = +95.0°C)
Core 1:       +36.0°C  (high = +85.0°C, crit = +95.0°C)
Core 9:       +27.0°C  (high = +85.0°C, crit = +95.0°C)
Core 10:      +39.0°C  (high = +85.0°C, crit = +95.0°C)

intel5500-pci-00a3
Adapter: PCI adapter
temp1:        +65.5°C  (high = +100.0°C, hyst = +95.0°C)
                       (crit = +110.0°C)

coretemp-isa-0000
Adapter: ISA adapter
Core 0:       +39.0°C  (high = +85.0°C, crit = +95.0°C)
Core 1:       +38.0°C  (high = +85.0°C, crit = +95.0°C)
Core 9:       +31.0°C  (high = +85.0°C, crit = +95.0°C)
Core 10:      +29.0°C  (high = +85.0°C, crit = +95.0°C)
```

Но большая часть информации через ipmicfg может взяться

```shell
sorshocking : ~ [0] # ipmicfg -pminfo
 [SlaveAddress = 78h] [Module 1]
 Item                           |                          Value
 ----                           |                          -----
 Status                         |              [STATUS OK] (00h)
 Input Voltage                  |                        227.2 V
 Input Current                  |                         0.52 A
 Main Output Voltage            |                        12.09 V
 Main Output Current            |                         9.37 A
 Temperature 1                  |                        33C/91F
 Temperature 2                  |                       41C/106F
 Fan 1                          |                       3968 RPM
 Fan 2                          |                          0 RPM
 Main Output Power              |                          113 W
 Input Power                    |                          126 W
 PMBus Revision                 |                           0x22
 PWS Serial Number              |                P7061VF28GT1194
 PWS Module Number              |                    PWS-706P-1R
 PWS Revision                   |                            1.1
 Current Sharing Control        |           Active - Active (80)

 [SlaveAddress = 7Ah] [Module 2]
 Item                           |                          Value
 ----                           |                          -----
 Status                         |              [STATUS OK] (00h)
 Input Voltage                  |                        226.5 V
 Input Current                  |                         0.59 A
 Main Output Voltage            |                        12.09 V
 Main Output Current            |                        10.50 A
 Temperature 1                  |                        35C/95F
 Temperature 2                  |                       41C/106F
 Fan 1                          |                       4384 RPM
 Fan 2                          |                          0 RPM
 Main Output Power              |                          127 W
 Input Power                    |                          147 W
 PMBus Revision                 |                           0x22
 PWS Serial Number              |                P7061VF28GT1193
 PWS Module Number              |                    PWS-706P-1R
 PWS Revision                   |                            1.1
 Current Sharing Control        |           Active - Active (80)
```


---
### Типы используемого сетевого адаптера и состоянии его интерфейсов?


```shell
sorsstorage13 : ~ [0] # lspci | grep net
01:00.0 Ethernet controller: Intel Corporation 82576 Gigabit Network Connection (rev 01)
01:00.1 Ethernet controller: Intel Corporation 82576 Gigabit Network Connection (rev 01


vm13 : ~ [255] # ip a s eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 3e:8e:90:47:59:70 brd ff:ff:ff:ff:ff:ff
    inet 5.101.156.76/24 brd 5.101.156.255 scope global eth0

```

Здесь можно увидеть понятие up, означает что интерфейс поднят

- UP — устройство подключено и готово принимать и отправлять фреймы;
- LOOPBACK — интерфейс является локальным и не может взаимодействовать с другими узлами в сети;
- BROADCAST - устройство способно отправлять широковещательные фреймы;
- POINTTOPOINT — соединение типа «точка-точка»
- PROMISC — устройство находится в режиме «прослушивания» и принимает все фреймы.
- NOARP — отключена поддержка разрешения имен сетевого уровня.
- ALLMULTI — устройство принимает все групповые пакеты.
- NO-CARRIER — нет связи (не подключен кабель).
- DOWN — устройство отключено.

---



### Подключённых USB и PCI устройствах?


### Подключённых USB и PCI устройствах?


- Ответ
    
    PC
    
    ```shell
    lspci -vvv
    ```
    

USB

```shell
lsusb -vvv
```

---


### Расскажи, как происходит процесс загрузки ОС linux с момента нажатия кнопки питания.






---


### Что за процессы в Linux c PID 0 и 1


- Ответ Процесс с PID 0 - это процесс swap (или идл процесс).
    
    Этот процесс не выполняет никаких задач, он является бездействующим. Процессор переходит к выполнению процесса 0, когда нет других активных процессов для выполнения.
    
    Процесс с PID 1 - это init процесс (или systemd в современных дистрибутивах Linux).
    
    Это первый процесс, который запускается во время загрузки системы после ядра Linux. Он является родительским процессом для всех остальных процессов в системе. init процесс отвечает за запуск различных системных служб и демонов при загрузке. Если init процесс завершается, это приводит к остановке всей системы.

---



### Что такое POSIX

- Ответ
    
    ### Интерфейс портативных операционных систем (POSIX)
    
    

- **Портативность** в контексте стандарта POSIX относится к исходному коду, а не к бинарным файлам, которые собираются из этого исходного кода. Это означает, что программы, написанные с соблюдением стандартов POSIX, могут быть скомпилированы и запущены на различных операционных системах без значительных изменений в исходном коде.
    
    **Интерфейс** — это способ взаимодействия вашего кода с остальной системой. POSIX определяет общий интерфейс, который описывает, как программы должны взаимодействовать с операционной системой.
    
    Таким образом, программы, разработанные для одной операционной системы, могут быть легко перенесены на другую, если обе системы поддерживают стандарт POSIX.
    
    Некоторые из ключевых аспектов POSIX включают:
    
    - **Семафоры** — механизм для синхронизации процессов и разделения ресурсов.
    - **Управление потоками** — стандарты для работы с потоками, синхронизации и управления ими.
    
    POSIX предоставляет основу для того, чтобы разработчики могли писать программы, которые будут совместимы с различными операционными системами, обеспечивая высокую степень переносимости кода.
    

---


### Что такое уровни выполнения (run levels) в Linux


- Ответ
    
    В Linux существует понятие **уровень выполнения** (_run level_), который обозначается числами от 0 до 6. Каждый уровень выполнения соответствует определённому состоянию системы.
    
    Система в любой момент времени находится на определённом уровне выполнения. Как системный администратор, вы можете переводить её с одного уровня выполнения на другой с помощью программы `init` (или `telinit`), передавая в качестве аргумента число, соответствующее нужному уровню выполнения.
    
    ### Описание уровней выполнения
    
    

- **0** — система выполняет действия по выключению.
- **1** — **однопользовательский режим** (_single user mode_). Предназначен для административных задач, например, восстановления системы. По функциональности напоминает безопасный режим (_Safe Mode_) в Windows, однако не является его полной аналогией. В этом режиме система сконфигурирована, но не запущен ни один сервис, и может работать только один пользователь — `root`.
- **2** — **многопользовательский режим без сетевых файловых систем**. Не используется во многих дистрибутивах, но в Debian используется как стандартный многопользовательский режим.
- **3** — **многопользовательский режим с сетевыми возможностями**. Это нормальный режим работы сервера без графического интерфейса.
- **4** — **не используется** в большинстве систем. В Slackware Linux используется для графического входа в систему.
- **5** — **графический режим**. В RedHat и SuSE Linux этот уровень используется для графического входа в систему. В Slackware не сконфигурирован.
- **6** — выполняются действия по перезагрузке системы.

### Примечания к уровням выполнения


- В большинстве современных систем уровни выполнения заменены на **systemd targets**, но принцип остаётся аналогичным.

---




### Какие основные части компоненты включает в себя система на базе дистрибутива linux?


---

### Что такое BIOS, UEFI? Основы и различия

---


### Что такое PXE? Как загрузиться по сети?


---


### Что такое ядро, initramfs, загрузчик?



---


### Зачем нужна система инициализации? Какие системы инициализации используются в современных дистрибутивах? (2 - 5 штук) (init)


- Ответ
    
    В операционной системе Linux и других системах семейства Unix после завершения загрузки ядра начинается инициализация Linux системы, сервисов и других компонентов. За это отвечает процесс инициализации, он запускается ядром сразу после завершения загрузки, имеет PID 1, и будет выполняться пока будет работать система.
    
    За время развития операционных систем были созданы различные системы инициализации Linux. В разных дистрибутивах использовались разные системы
    
    Есть init. Это первый процесс, родительский процесс, которые все процессы запускает. Проверка, монитрование файловых систем, запуск служб.
    
    Есть три его варианты работы
    
    **System V init (SysV)**
    
    Это загрузка, основанная на уровне запуска. Обычно их семь. Ну там включение, выключение, режим восстановления и тп.
    
    То есть процесс инициализирует на одном из уровней запуска системы
    
    **SystemD**
    
    Родительский процесс, который запускает инициализацию в ускоренном режиме за счет параллельного запуска задач. Ускоренный режим достигается за счет особенностей работы процессора. И если они позволяют, запускает инициализацию параллельно.
    
    **Upstart**
    
    Здесь запускаются скрипты инициализации, отслеживает события, и реагирует на них. Более гибкий процесс инициализации. Если какая-то служба не запустилась, или вдруг упала, то апстарт это отследит и запустит повторно.



---

### Что такое systemd и init ? В чем основное преимущество первого над вторым ?


- Ответ И то, и то система инциализации.
    
    В чём конкретно преимущества для меня systemd над init:
    
    - Параллельный старт процессов, в отличие от init
    - Запуск системы с ним быстрее происходит.
    - Не нужно городить костыли на баше — использую простенький шаблон для юнитов, в отличие от баш портянки.
    - Не нужно городить километровые пайпы для чтения нужной информации из логов — для всего есть человекопонятные опции;
    - Автоматический рестарт юнитов при падении — не нужно плясать с бубном вокруг ряда сервисов, если выпал один промежуточный;
    - Простая и понятная настройка всего — несколько конфигов (а не тонны, раскиданные по всей системе, как было в легаси) с парами ключ=значение;
    - Хорошая документированность (я не говорю, что легаси-набор плохо документирован, я лишь говорю, что systemd не уступает);
    - Он не только загрузчик, но и система инициализирующая демоны




---


### Как понять используется ли в системе systemd?


- Ответ
    
    `/run/systemd/` говорит о наличии systemd в системе.
    
    `/run/systemd/system/` - говорит о том, что это активная система инициализации
    
    Можно через stat узнать
    
    Если есть симлинк - используется systemd.
    
    ```
    stat /sbin/init
    File: ‘/sbin/init’ -> ‘../lib/systemd/systemd’
    ```
    

Можно сделать ещё через процесс 1, и через файловую систему `/proc`:

```
root@swfuse:~# stat /proc/1/exe 
File: /proc/1/exe -> /lib/systemd/systemd
Size: 0         	Blocks: 0          IO Block: 1024   symbolic link
Device: 4h/4d	Inode: 444358      Links: 1
Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2022-06-20 00:00:01.579875809 +0000
Modify: 2022-06-09 17:19:41.581240179 +0000
Change: 2022-06-09 17:19:41.581240179 +0000
```


---
### Опишите, что происходит (с точки зрения процессов), при выполнении любой команды в консоли, например:



`$ ls -l`

- **Ответ**
    
    При выполнении команды в консоли происходит системный вызов fork(), в результате которого создаётся копия процесса консоли, затем копия процесса выполняет команду с помощью системного вызова exec().
    
    После выполнения команды, копия процесса выполняет системный вызов exit(), в результате которого оригинальному процессу консоли отправляется сигнал SIGCHLD (сообщающий о том, что дочерний процесс завершён).
    
    Во время работы копии процесса, оригинальный процесс находится в ожидании из-за системного вызова wait().


---


**Как работает система разграничения доступа к файлам в linux? Какие возможности она предоставляет?**

- Ответ
    
    [https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-1/](https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-1/)
    
    [https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-2/](https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-2/)
    
    [https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-3/](https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-3/)
    
    - Оболочка проверяет, являетесь ли вы владельцем файла, к которому вы хотите получить доступ. Если вы являетесь этим владельцем, вы получаете разрешения и оболочка прекращает проверку.
    - Если вы не являетесь владельцем файла, оболочка проверит, являетесь ли вы участником группы, у которой есть разрешения на этот файл. Если вы являетесь участником этой группы, вы получаете доступ к файлу с разрешениями, которые для группы установлены, и оболочка прекратит проверку.
    - Если вы не являетесь ни пользователем, ни владельцем группы, вы получаете права других пользователей (Other).


---

### Как посмотреть нагрузку на диски?


- Ответ
    
    Установить утилиту `sysstat`, проверить нагрузку на диски `iostat -xtc`.  
    Использовать утилиту `iotop`, которая показывает процессы, которые активно используют диск.  
    Использовать `dstat` - утилита, которая выводит раз в какое-то время статистику по системным ресурсам. В целом более удобная замена таких утилит как vmstat, iostat, ifstat

---


### В чем разница между объявлением переменной `export VAR="VALUE"` и `VAR="VALUE"` в bash?


- Ответ
    
    При объявлении переменной через **export** - переменная будет доступна в любых других процессах.
    
    При обычном объявлении переменной - переменная будет доступна только в запущенном процессе.


---


### Что значит `$@`, `$!`, `$?`, `$$` в bash?


- Ответ
    
    `$@` - показывает все параметры переданные скрипту.  
    `$!` - показывает pid последнего процесса, которая оболочка запустила в фоновом режиме.  
    `$$` - показывает текущий pid процесса.  
    `$?` - показывает с каким кодом завершилась последняя выполненная функция. 0 - успешное выполнение.

---


### Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?


- Ответ
    
    ```shell
    cmd 2>&1 >/dev/null | grep pattern
    ```

---

### При перенаправлении команд (command1 | command2 ) перенаправляется только stdout. Как сделать так, чтобы stderr тоже перенаправлялся?


- Ответ Либо использовать перенаправление. То есть перенаправляется второй файловый дескриптор туда, куда направлен stdout:  
    `command1 2>&1 | command2`
    
    Либо использовать более укороченную версию:  
    `command1 |& command2`

---

### Как посмотреть описание дескриптора? Как посмотреть время последней модификации файла?

- Ответ
    
    Посмотреть полную информацию по дескриптору возможно командой `stat <path_to_file>`.
    
    Время модификации командой `stat --format=%y dira`

---


### Как работает sudo? Для чего она используется?


- Ответ
    
    Sudo позволяет подменить пользователя и выполнить команду от его имени. Расшифровывается именно так - **s**ubstitute **u**ser and **do**
    
    По умолчанию выполнение команды происходит от имени суперпользователя.
    
    Например, вот эта команда
    
    ```shell
    sudo whoami
    ```
    

И вот эта

```shell
sudo -u swfuse whoami
```

Будет отличаться результатом.

Можно просмотреть какие полномочия есть с помощью команды:

```shell
sudo -l
```

---


### Что такое системные вызовы? Зачем они нужны и как они работают? Какие системные вызовы знаешь (5-10)


- Ответ
    
    **Системный вызов** — это то, посредством чего код приложения, выполняющегося в пользовательском режиме, запрашивает службу, предоставляемую кодом, который выполняется в режиме ядра.
    
    **read** - чтение из файлового дескриптора.
    
    **open** - открывающий и по возможности создающий файл или устройство
    
    **close -** закрыть файловый дескриптор
    
    **access -** проверка пользовательских привелегий для этого файла
    
    **mmap** - служит для отображения предварительно открытого файла (например, с помощью системного вызоваа open()) в адресное пространство вычислительной системы
    
    Команда для вывода всех системных вызовов во время исполнения программы:
    
    ```shell
    strace -c ls
    % time     seconds  usecs/call     calls    errors syscall
    ------ ----------- ----------- --------- --------- ----------------
      0.00    0.000000           0         4           read
      0.00    0.000000           0         5           write
      0.00    0.000000           0         6           open
      0.00    0.000000           0         9           close
      0.00    0.000000           0         7           fstat
      0.00    0.000000           0        18           mmap
      0.00    0.000000           0        10           mprotect
      0.00    0.000000           0         2           munmap
      0.00    0.000000           0         3           brk
      0.00    0.000000           0         2           rt_sigaction
      0.00    0.000000           0         1           rt_sigprocmask
      0.00    0.000000           0         2           ioctl
      0.00    0.000000           0         6         6 access
      0.00    0.000000           0         1           execve
      0.00    0.000000           0         2           getdents
      0.00    0.000000           0         1           getrlimit
      0.00    0.000000           0         1           arch_prctl
      0.00    0.000000           0         1         1 futex
      0.00    0.000000           0         1           set_tid_address
      0.00    0.000000           0         1           openat
      0.00    0.000000           0         1           set_robust_list
    ------ ----------- ----------- --------- --------- ----------------
    100.00    0.000000                    84         7 total
    ```


---

### Где можно найти информацию о конкретном системном вызове?


- Ответ
    
    `man 2 <syscall>`
    
    Но нужно будет предварительно поставить пакет `man-pages`
    
    ```
    sudo apt install manpages-dev manpages-posix-dev
    ```


---

### Что делает команда kill?


- Ответ
    
    Назначение команды kill - отправить определенный сигнал процессу. По умолчанию используется сигнал SIGTERM.

---


### Текущая load average на сервере - 900, 900, 900. Сервер работает с незначительной потерей производительности. Каким образом можно понять, является ли это нормальной ситуацией?


- Ответ
    
    Я бы начал с того, что бы понял а что вообще вызывает проблему, и что на сервере важное. Что работает, а что не работает.
    
    Если сайтики не открываются на работающем сервере все - проблема. Если проблема только с одним, то копать. А может быть все важные функции работают для работы сайтов или сервисов.
    
    И допустим нужно писать данные или читать данные на что-то медленное. Система не тормозит, но из-за того, что процессы записи чтения на медленный девайс скопились - ЛА подросла. В этом случае будет высокая wa При этом все остальные процессы отрабатывают быстро
    
    На параметр нагрузки LA влияет также и ожидание ввода-вывода (параметр _wa_ в утилите _top_ ) в дисков и задержка сети. Данные параметры могут не влиять на работу основных сервисов в системе, но учитываются при расчете общей нагрузки на систему.
    
    Иными словами на сервере с активными приложениями высокий LA скорее всего будет проблемной ситуацией. А на сервере с бэкапами высокий LA может проблемой не быть. Поскольку туда постоянно пишутся данные, и la растет просто из-за того, что копятся процессы, которые ожидают очереди записи на диск.

---

### Что такое процесс? Что такое тред? В чем заключаются их главные отличия?


- Ответ
    
    **Процесс** - это исполняемая программа. Когда программист пишет программу и выполняет ее, эта программа становится процессом. Он выполняет задачи в соответствии с инструкциями программы.
    
    **Процесс** - это экземпляр выполняемой компьютерной программы. **Поток** - это компонент процесса, который является самой маленькой исполнительной единицей.
    
    Можно представить процессы и потоки на примере задачи "Починка дороги".
    
    Хорошо, как я могу построить дорогу, поэтому мне нужен какой-то ресурс для строительства, верно?
    
    Выделяемые ресурсы:
    
    1. Граница дороги (область)
    
    - Технически мы можем назвать это виртуальным адресным пространством, оно имеет уникальный идентификатор процесса для идентификации работы.
    - Доступ к ограниченной границе области. Контекст безопасности
    - Также, вы можете сопоставить другие свойства процесса с приведенным выше примером (окружение, приоритет и т.д.)
    
    1. Жесткое или рабочее пространство
    
    - Количество "оборудования или рабочей силы" основано на мышлении подрядчика; предположим, что он хочет закончить работу быстро, тогда он должен назначить больше людей на эту работу.
    - Т.е. каждый работник может получить доступ к этой ограниченной территории (общее пограничное пространство).
    - Для начала работы нужен хотя бы один человек один поток.
    - У каждого человека есть свой идентификатор
    
    Ключевая разница
    
    - Процесс означает, что программа выполняется, а поток означает сегмент процесса.
    - Процесс не является легковесным, тогда как потоки - легковесными.
    - Процессу требуется больше времени для завершения, а потоку требуется меньше времени для завершения.
    - Процесс требует больше времени для создания, тогда как поток требует меньше времени на создание.
    - Процессу, требуется больше времени для переключения контекста, тогда как потокам требуется меньше времени для переключения контекста.
    - **Процесс в основном изолирован, тогда как потоки разделяют память.**
    - Процесс не обменивается данными, а потоки обмениваются данными друг с другом.




---




