fg - команда возобновления работы задачи

К примеру мы запустили :
ping ya.ru

после чего нажали CTRL + Z - в фон ушел процесс.
Так же если ввести : ps, то пинг процесс будет виден
что бы войти в в процесс ping прописываем fg к командной строке.

---

### Создание линков.

ln -s "на что делаем" "куда положить линк"
(делаем всегда полный путь на линк)

---

**wc** - команда


root@user:/run# wc motd.dynamic
  29  120 1002 motd.dynamic

Сколько строчек в файле - 29
Сколько слов - 120
Сколько символов - 1002

root@user:/run# wc -l motd.dynamic - считает строки
root@user:/run# wc -w motd.dynamic - считает слова

---

 **sort** - команда, сортирует по алфавиту, по номерам с начала

root@user:/var/log# du -h | sort -h

-h - отсортировать файлы по размеру

root@user:/run# sort motd.dynamic
1
2
3
5
6
LINUX
PATRON
PATRONNIKE
PINGVIN


---
**cut** - разделяет поля и выводит нужные.

root@user:/etc# cat shadow
root:$y$j9T$GgcQDInDRaI7q8swWLoA4.$beIbkZ0lT8pCsguaXpOneBH3McsPpr0OfA4eMbzcL33:20071:0:99999:7:::
daemon:*:19977:0:99999:7:::
bin:*:19977:0:99999:7:::
sys:*:19977:0:99999:7:::
sync:*:19977:0:99999:7:::
games:*:19977:0:99999:7:::
man:*:19977:0:99999:7:::
lp:*:19977:0:99999:7:::
mail:*:19977:0:99999:7:::
news:*:19977:0:99999:7:::
uucp:*:19977:0:99999:7:::
proxy:*:19977:0:99999:7:::
www-data:*:19977:0:99999:7:::
backup:*:19977:0:99999:7:::
list:*:19977:0:99999:7:::




root@user:/etc# **cut** -d ":" -f 3 shadow
20071
19977
19977
19977
19977
19977
19977
19977

-d - что будет разделителем
-f - выбираем столбец

---
grep -E "(one|tho)" имя.файла - то что в скобках, или то или то, если есть оба в файле, выведет оба



---


### **Перенаправление вывода и ввода.**

Если к примеру есть файл с текстом name.txt
если хотим отсортировать его с помощью sort и заменить ранее файл, то :

sort name.txt > name.txt - внутри файла просто все сотрется, и он будет пустой

если  не перезаписать, а добавить :
sort name.txt >> name.txt, в таком случае старое останется и добавит еще новое


**Распределить потоки.**

Если мы ищем какой-то файл, то в некоторых директориях он может не показаться, так как недостаточно прав "Permission denied" 

Пример :

user@user:/etc$ grep user /etc/*
*/etc/adduser.conf:# /etc/adduser.conf: 
/etc/adduser.conf:# See adduser(8) and adduser.conf(5) for full documentation.
grep: /etc/sudoers: Permission denied
grep: /etc/sudoers.d: Is a directory

но нам нужно вывести без ошибок поток, в таком случае пишем :

user@user:/etc$ grep user /etc/* 2> /dev/null

то есть "2> /dev/null" перенаправить ошибки в никуда

Либо можно указать файл, куда будут перенесены все ошибки

user@user:/etc$ grep user /etc/* 2> errors.txt

Если выставить 1, то  будет наоборот, вывод с ошибками увидим в консоли, в файле будет нужный вывод.


### **Архивирование и сжатие.**


**Сжатие в архив**

tar -cf mytar.tar  test1

c - создать архив
f - в файле создать архив, f всегда должна быть последней
z - сжать в архив gzip, без этого параметра tar не сжимает
v - вывод на экран процесс.
t - посмотреть что есть в архиве

**Распаковать** 

tar -xvf mytar.tar

---

whereis имя - ищем файл какой-то, после чего покажет путь к нему.

---


crontab  - выполнение скриптов, задач по расписанию.
crontab -e - создать задачу на выполнение

|              |                                               |
| ------------ | --------------------------------------------- |
| **Параметр** | **Допустимый интервал**                       |
| минуты       | 0-59                                          |
| часы         | 0-23                                          |
| день месяца  | 1-31                                          |
| месяц        | 1-12                                          |
| день недели  | 0-7 (0-Вс,1-Пн,2-Вт,3-Ср,4-Чт,5-Пт,6-Сб,7-Вс) |

Каждую минуту будет слать текст qqq в файл test.txt

```
* * * * * echo "qqq" >> /script/test.txt
```


Если нужно к примеру что бы именно каждые две минуты пересылалось :

```
*/2 * * * * echo "qqq" >> /script/test.txt
```


Каждые две минуты, каждого второго часа :

```
*/2 */2 * * * echo "qqq" >> /script/test.txt
```

---

root@user:/var/log# du -h | sort -rh | head -3
120M    .
105M    ./journal/31ad0289447e4dd3a6f3132b5682af56
105M    ./journal
root@user:/var/log#

-r - сортируем наоборот, с большего к малому
head -3 - только 3 строки


---
root@user:/# find /var/log/ -type f | wc -l
209
root@user:/# find /var/log/ -type d | wc -l
31

209 - файлов
31 - директория


---


`find / -user root -type f -perm /u=s -exec ls -l {} \; 2> /dev/null`

1. **`find /`** — команда `find` ищет файлы в каталоге и его подкаталогах. Здесь она начинает поиск с корня файловой системы `/`.
    
2. **`-user root`** — фильтрует файлы, принадлежащие пользователю с именем "root".
    
3. **`-type f`** — ограничивает поиск только файлами (не директориями, ссылками и т.д.).
    
4. **`-perm /u=s`** — ищет файлы с установленным флагом SUID (Set User ID), который указывает на то, что файл будет выполняться с правами владельца (в данном случае пользователя root). `/u=s` означает, что флаг SUID должен быть установлен для владельца файла (root).
    
5. **`-exec ls -l {} \;`** — для каждого найденного файла выполняется команда `ls -l` для получения подробной информации о файле (включая права доступа, владельца, размер и дату последнего изменения). `{}` — это плейсхолдер для имени каждого найденного файла, а `\;` указывает на завершение команды `exec`.
    
6. **`2> /dev/null`** — перенаправляет стандартный поток ошибок (stderr) в "пустое" устройство `/dev/null`, что означает игнорирование любых ошибок (например, если команда не имеет прав доступа к некоторым файлам).